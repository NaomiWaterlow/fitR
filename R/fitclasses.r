#'Constructor of fitmodel object
#'
#'A \code{fitmodel} object contains all the information necessary to simulate and fit a model during the course. When a model is created, the constructor performs a serie of checks
#'on the arguments provided by the user in order to make sure that the different elements of the \code{fitmodel} will be compatible both with the functions coded during the course and the functions
#'available in the \code{fitR} package. The latter can be used as a correction.
#' @param name character, name of the model (required)
#' @param state.variables character vector, names of the state variables i.e. \code{c("S","I","R","Incidence")} (required)
#' @param simulate.model \R function to simulate forward the model. This function takes 3 arguments:
#' \itemize{
#' \item \code{theta} named vector of model parameters.
#' \item \code{state.init} named vector of initial state of the model.
#' \item \code{times} time sequence for which state of the model is wanted; the first value of times must be the initial time.
#' }
#' and returns a \code{data.fame} containing the values of the state variables (1 per column) at each observation time (1 per row).
#' @param generate.observation \R-function to generate simulated data from a simulated trajectory using an observation model. This function takes 2 arguments:
#' \itemize{
#' \item \code{model.traj} data.frame of simulated trajectories, as returned by \code{simulate.model}.
#' \item \code{theta} named vector of model parameters.
#' }
#' and return the \code{model.traj} data.frame with an additional "observation" column generated by the observation model. (optional)
#' @param log.prior \R function to evaluate the log-prior distribution for a given (named) vector of model parameters. (optional) The function should take 1 argument:
#'#' \itemize{
#' 	\item \code{theta} named vector of model parameters
#' }
#' and returns the logged value of the prior density distribution. Required if at least one parameter is estimated. See note below.
#' @param log.likelihood \R function to evaluate the log-likelihood of the data given a model parameter \code{theta} and a simulated trajectory \code{model.traj}. This function takes 3 arguments:
#' \itemize{
#' \item \code{data} data.frame containing all or part of the observations.
#' \item \code{theta} named vector of model parameters.
#' \item \code{model.traj} data.frame containing the state of the model at the successive observation times, as returned by \code{simulate.model}.
#' }
#' and return the log-likelihood. (optional)
#' @param verbose if \code{TRUE}, print details of the test performed to check validity of the arguments
#' @export
#' @return a \code{fitmodel} object that is a \code{list} of 9 elements:
#' \itemize{
#' 	\item \code{name} name of the model
#' 	\item \code{state.variables} vector names of the state variables.
#' 	\item \code{simulate.model} \R function to simulate forward the model; usage: \code{simulate.model(theta,state.init,times)}.
#' 	\item \code{generate.observation} \R function to generate simulated observation; usage: \code{generate.observation(model.traj, theta)}.
#' 	\item \code{log.prior} \R function to evaluate the log-prior; usage: \code{log.prior(theta)}.
#' 	\item \code{log.likelihood} \R function to evaluate the log-likelihood; usage: \code{log.likelihood(data, theta, model.traj)}.
#' }
#' @example inst/examples/example-fitmodel.r
fitmodel <- function(name=NULL, state.variables=NULL, simulate.model=NULL, generate.observation=NULL, log.prior=NULL, log.likelihood=NULL){

	# mandatory
	if(!is.character(name)){
		stop(sQuote("name")," argument is not a character")
	}
	if(!is.character(state.variables)){
		stop(sQuote("state.variables")," argument is not a character vector")
	}

	if(!is.null(simulate.model)) {
		if(!is.function(simulate.model)){
			stop(sQuote("simulate.model")," argument is not an R function")
		}
		## if(is.null(initialise.state)) {
		## 	stop(sQuote("initialise.state")," must be provided when", sQuote("simulate.model"), " is given")
		## } else if(!is.function(initialise.state)) {
		## 	stop(sQuote("initialise.state")," argument is not an R function")
		## }
	}
	# optional
	if(!is.null(log.prior) && !is.function(log.prior)){
		stop(sQuote("log.prior")," argument is not an R function")
	}
	if(!is.null(log.likelihood) && !is.function(log.likelihood)){
		stop(sQuote("log.likelihood") ," argument is not an R function")
	}
	if(!is.null(generate.observation) && !is.function(generate.observation)){
		stop(sQuote("generate.observation")," argument is not an R function")
	}

	# create and return object
	return(structure(list(
		name=name,
		state.variables=state.variables,
		simulate.model=simulate.model,
		generate.observation=generate.observation,
		log.prior=log.prior,
		log.likelihood=log.likelihood), class="fitmodel"))

}

testFitmodel <- function(model, theta, state.init = NULL, data = NULL, verbose=TRUE) {

        ## create the named vector of theta
	names.theta <- names(theta)

	## # check initialise.state
	## if(!is.null(initialise.state)) {
	## 	if(verbose){
	## 		cat("--- check initialise.state\n")
	## 	}
	## 	fun_args <- c("theta")
	## 	if(!all(x <- fun_args%in%names(formals(initialise.state)))){
	## 		stop("argument(s) ",paste(fun_args[!x],collapse=", ")," missing in function initialise.state, see documentation.")
	## 	}

	## 	test.initial.state <- initialise.state(theta=theta)

	## 	if(verbose){
	## 		cat("initialise.state(theta) should return a non-negative numeric vector of dimension ",length(state.variables)," with names: ",paste(state.variables,collapse=", "),"\nTest:\n")
	## 		print(test.initial.state)
	## 	}
	## 	if(!is.vector(test.initial.state)){
	## 		stop("initialise.state must return a vector")
	## 	}
	## 	if(!all(x <- state.variables%in%names(test.initial.state))){
	## 		stop("State variable(s) missing in the vector returned by the function initialise.state:",paste(state.variables[!x],collapse=", "))
	## 	}
	## 	if(!all(x <- names(test.initial.state)%in%state.variables)){
	## 		stop("The following state variables should not be returned by the function initialise.state since they are not defined in state.variables:",paste(names(test.initial.state)[!x],collapse=", "))
	## 	}
	## 	if(any(x <- test.initial.state<0)){
	## 		stop("The following state variables are negative:",paste(test.initial.state[x],collapse=", "))
	## 	}
	## 	if(verbose){
	## 		cat("--> initialise.state looks good!\n")
	## 	}
	## }

        test.traj <- NULL

	## check simulate.model
	if(!is.null(model$simulate.model)) {
		if(verbose){
			cat("--- checking simulate.model\n")
		}
                ## check arguments
		fun_args <- c("theta","state.init","times")
		if(!(all(x <- fun_args%in%names(formals(model$simulate.model))))){
			stop("argument(s) ",paste(fun_args[!x],collapse=", ")," missing in function simulate.model, see ?fitmodel.")
		}

                if (!is.null(state.init)) {
                        times <- 0:10
                        test.traj <- model$simulate.model(theta=theta,state.init=state.init,times=times)
                                        # must return a data.frame of dimension 11x(length(state.variables)+1)
                        if(verbose){
                                cat("simulate.model(theta, state.init, times=0:10) should return a non-negative data.frame of dimension",length(times),"x",length(model$state.variables)+1,"with column names:",paste(c("time",model$state.variables),collapse=", "),"\nTest:\n")
                                print(test.traj)
                        }
                        if(!is.data.frame(test.traj)){
                                stop("simulate.model must return a data.frame")
                        }
                        if(!all(x <- c("time",model$state.variables)%in%names(test.traj))){
                                stop("Column(s) missing in the data.frame returned by simulate.model: ",paste(c("time",model$state.variables)[!x],collapse=", "))
                        }
                        if(!all(x <- names(test.traj)%in%c("time",model$state.variables))){
                                warning("The following columns are not required in the data.frame returned by simulate.model: ",paste(names(test.traj)[!x],collapse=", "))
                        }
                        if(any(test.traj$time!=times)){
                                stop("The time column of the data.frame returned by simulate.model is different from its times argument",call.=FALSE)
                        }
                        if(any(test.traj<0)){
                                stop("simulate.model returned negative values during the test, use verbose argument of fitmodel to check")
                        }
                        if(verbose){
                                cat("--> simulate.model looks good!\n")
                        }
                } else {
                        warning("state.init not given, not creating test trajectory\n")
                }
	} else {
                warning("model does not contain a simulate.model method -- not tested\n")
        }

	## check generate.observation
	if(!is.null(model$generate.observation)) {
		if(verbose){
			cat("--- checking generate.observation\n")
		}
                ## check arguments
		fun_args <- c("model.traj","theta")
		if(!(all(x <- fun_args%in%names(formals(model$generate.observation))))){
			stop("argument(s) ",paste(fun_args[!x],collapse=", ")," missing in function generate.observation, see ?fitmodel.")
		}

                if (!is.null(test.traj)) {
                        test.generate.observation <- model$generate.observation(test.traj, theta)
                        if(verbose){
                                cat("generate.observation(test.traj, theta) should return a non-negative data.frame of dimension",nrow(test.traj),"x",ncol(test.traj)+1,"with column names:",paste(c(names(test.traj),"observation"),collapse=", "),"\nTest:\n")
                                print(test.generate.observation)
                        }
                        if(!is.data.frame(test.generate.observation)){
                                stop("generate.observation must return a data.frame")
                        }
                        if(!all(x <- c(names(test.generate.observation),"observation")%in%names(test.generate.observation))){
                                stop("Column(s) missing in the data.frame returned by generate.observation:",paste(c("time",model$state.variables)[x],collapse=", "))
                        }
                        if(!all(x <- names(test.generate.observation)%in%c(names(test.generate.observation),"observation"))){
                                warning("The following columns are not required in the data.frame returned by generate.observation:",paste(names(test.generate.observation)[x],collapse=", "))
                        }
                        if(nrow(test.generate.observation)!=nrow(test.traj)){
                                stop("The data.frame returned by generate.observation must have the same number of rows as the model.traj argument",call.=FALSE)
                        }
                        if(any(test.generate.observation$observation<0)){
                                stop("generate.observation returned negative observation during the test, use verbose argument of fitmodel to check")
                        }
                        if(verbose){
                                cat("--> generate.observation looks good!\n")
                        }
                } else {
                        warning("no test trajectory created, not creating test observation\n")
                }
	}

	## # build covariance matrix
	## covmat.proposal <- gaussian.proposal$covmat

	## if(!is.null(covmat.proposal)){

	## 	# check covmat proposal
	## 	if(verbose){
	## 		cat("Check covariance matrix of the gaussian proposal kernel:\n")
	## 		print(covmat.proposal)
	## 	}
	## 	# must be a square matrix with same row and col names
	## 	if(nrow(covmat.proposal)!=ncol(covmat.proposal)){
	## 		stop("gaussian.proposal$covmat is not a square matrix")
	## 	}
	## 	if(length(setdiff(rownames(covmat.proposal),colnames(covmat.proposal)))){
	## 		stop("row names and col names of gaussian.proposal$covmat don't match")
	## 	}

	## 	# check whether all names correspond to existing theta
	## 	names.unknown.theta <- setdiff(rownames(covmat.proposal),names.theta)
	## 	if(length(names.unknown.theta)){
	## 		stop("The following parameter names in gaussian.proposal$covmat do not match those of list.fitparam: ",paste(names.unknown.theta,collapse=", "))
	## 	}

	## 	# check that all theta are in gaussian.proposal$covmat
	## 	names.missing.theta <- setdiff(names.theta,rownames(covmat.proposal))
	## 	if(length(names.missing.theta)){
	## 		# if missing theta => set their variances to 0 (not estimated)
	## 		warning("Parameter(s): ",paste(names.missing.theta,collapse=", ")," missing in gaussian.proposal$covmat. The matrix will be updated to include missing theta but they won't be estimated (proposal variance = 0).",call.=FALSE)
	## 		new.covmat.proposal <- matrix(0,ncol=length(names.theta),nrow=length(names.theta),dimnames=list(names.theta,names.theta))
	## 		new.covmat.proposal[rownames(covmat.proposal),colnames(covmat.proposal)] <- covmat.proposal
	## 		covmat.proposal <- new.covmat.proposal
	## 	}
	## 	if(verbose){
	## 		cat("--> gaussian.proposal$covmat looks good!\n")
	## 	}


	## }else{
	## 	# use list.fitparam
	## 	covmat.proposal <- diag(sapply(list.fitparam,function(x) {(x$sd.proposal)^2}), nrow = length(list.fitparam))
	## 	rownames(covmat.proposal) <- colnames(covmat.proposal) <- names.theta

	## }

	## gaussian.proposal$covmat <- covmat.proposal

	## # extract list of estimated theta
	## estimated.theta <- names(which(diag(covmat.proposal)>0))

	## # if any estimated theta do some tests on required arguments
	## if(length(estimated.theta)){

	## 	# check that all estimated theta have a prior (if so, prior has alreday been tested in fitparam)
	## 	if(any(x <- sapply(list.fitparam[estimated.theta],function(x) {is.null(x$prior$distribution)}))){
	## 		stop("Prior argument in fitparam must be defined for the following theta:",paste(estimated.theta[x],collapse=", "),call.=FALSE)
	## 	}

	## 	if(is.null(log.prior.fitparam)){
	## 		stop(sQuote("log.prior.fitparam")," argument must be provided because at least 1 parameter is marked as estimated")
	## 	}
	## 	if(is.null(data)){
	## 		stop(sQuote("data")," argument must be provided because at least 1 parameter is marked as estimated")
	## 	}
	## 	if(is.null(log.likelihood) && is.null(distance.ABC)){
	## 		stop("Either",sQuote("log.likelihood")," or ", sQuote("distance.ABC")," arguments must be provided because at least 1 parameter is estimated")
	## 	}

	## 	if(!is.null(lower <- gaussian.proposal$lower)){
	## 		## check lower truncations

	## 		# subset lower to parameter names
	## 		lower <- lower[intersect(names(lower),names.theta)]
	## 		# fill missing theta with -Inf
	## 		names.default <- setdiff(names.theta,names(lower))
	## 		lower.default <- rep(-Inf,length(names.default))
	## 		names(lower.default) <- names.default
	## 		# bind
	## 		lower <- c(lower,lower.default)
	## 		# reorder
	## 		lower <- lower[names.theta]
	## 	}else{
	## 		#use list.fitparam
	## 		lower <- sapply(list.fitparam,function(x) {min(x$support)})
	## 		names(lower) <- names.theta
	## 	}

	## 	if(!is.null(upper <- gaussian.proposal$upper)){
	## 		## check upper truncations
	## 		upper <- upper[intersect(names(upper),names.theta)]
	## 		# fill missing theta with -Inf
	## 		names.default <- setdiff(names.theta,names(upper))
	## 		upper.default <- rep(Inf,length(names.default))
	## 		names(upper.default) <- names.default
	## 		# bind
	## 		upper <- c(upper,upper.default)
	## 		# reorder
	## 		upper <- upper[names.theta]
	## 	}else{
	## 		#use list.fitparam
	## 		upper <- sapply(list.fitparam,function(x) {max(x$support)})
	## 		names(upper) <- names.theta
	## 	}

	## 	# check lower < upper
	## 	if(any(x <- (lower >= upper))){
	## 		stop("lower must be < than upper for parameter(s): ",paste(names(x)[x],collapse=", "),call.=FALSE)
	## 	}
	## 	gaussian.proposal$lower <- lower
	## 	gaussian.proposal$upper <- upper

	## 	if(verbose){
	## 		cat("--> Gaussian proposal will be truncated to:\n")
	## 		print(data.frame(lower=lower,upper=upper))
	## 	}

	## }

	if (!is.null(model$log.prior)) {
		if(verbose){
			cat("--- checking log.prior\n")
		}

		# check arguments
		fun_args <- c("theta")
		if(!(all(x <- fun_args%in%names(formals(model$log.prior))))){
			stop("arguments ",paste(fun_args[!x],collapse=", ")," missing in function log.prior, see ?fitmodel.")
		}

		# test it
		test.log.prior <- model$log.prior(theta)
		if(verbose){
			cat("log.prior(theta) should return a single finite value\nTest:",test.log.prior,"\n")
		}
		if(!(!is.na(test.log.prior) && (is.finite(test.log.prior)))){
			stop("log.prior must return a finite value for test parameter values")
		}
		if(verbose){
			cat("--> log.prior looks good!\n")
		}
	} else {
                warning("model does not contain a log.prior method -- not tested\n")
        }

	## # data must have a column named time, should not start at 0
	## if (!is.null(data)) {
	## 	if(!"time"%in%names(data)){
	## 		stop("data argument must have a column named \"time\"")
	## 	}else if(data$time[1]==0){
	## 		stop("the first observation time in data argument should not be 0")
	## 	}
	## }

        ## check log.likelihood
        ## check arguments, return value
        if (!is.null(model$log.likelihood)) {

		if(verbose){
			cat("--- checking log.likelihood\n")
		}
		# check arguments
		fun_args <- c("data","theta","model.traj")
		if(!(all(x <- fun_args%in%names(formals(model$log.likelihood))))){
			stop("argument(s) ",paste(fun_args[!x],collapse=", ")," missing in function log.likelihood, see documentation.")
		}

		if (!is.null(data)) {
                        if (!is.null(test.traj)) {

                                ## test it
                                test.log.likelihood <- model$log.likelihood(data=data,theta=theta,model.traj=test.traj)

                                if(verbose){
                                        cat("log.likelihood(model.traj,data,theta) should return a single value\nTest:",test.log.likelihood,"\n")
                                }
                                if(is.na(test.log.likelihood) || (test.log.likelihood > 0)){
                                        stop("log.likelihood must return a non-positive value")
                                }
                                if(verbose){
                                        cat("--> log.likelihood looks good!\n")
                                }
                        } else {
                                warning("no test trajectory created, not creating test observation\n")
                        }
                } else {
                        warning("data argument not given -- not testing log.likelihood function")
                }
        } else {
                warning("model does not contain a log.likelihood method -- not tested\n")
        }

	##  # check distance.ABC
	## # check arguments, return value
	## if (!is.null(distance.ABC)) {

	## 	if (is.null(data)) {
	## 		stop(sQuote("data") ," argument must be provided for ABC inference")
	## 	}
	## 	if (is.null(generate.observation)){
	## 		stop(sQuote("generate.observation")," argument must be provided for ABC inference")
	## 	}
	## 	# check arguments
	## 	fun_args <- c("model.traj.obs","data")
	## 	if(!(all(x <- fun_args%in%names(formals(distance.ABC))))){
	## 		stop("argument(s) ",paste(fun_args[!x],collapse=", ")," missing in function ",sQuote("distance.ABC")," see documentation.")
	## 	}

        ## # test it
        ## # test.generate.observation has been succesfully generated above (otherwise generate.observation is missing or corrupt and fitmodel has already thrown an error)
	## 	test.distance.ABC <- distance.ABC(data=data,model.traj.obs=test.generate.observation)

	## 	if(verbose){
	## 		cat("distance.ABC(model.traj.obs,data) should return a numeric vector\nTest:",test.distance.ABC,"\n")
	## 	}
	## 	if(is.na(test.distance.ABC) || !is.numeric(test.distance.ABC)){
	## 		stop("distance.ABC must return a numerci vector")
	## 	}
	## 	if(verbose){
	## 		cat("--> distance.ABC looks good!\n")
	## 	}
	## }

}
