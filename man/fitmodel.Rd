% Generated by roxygen2 (4.0.1): do not edit by hand
\name{fitmodel}
\alias{fitmodel}
\title{Constructor of fitmodel object}
\usage{
fitmodel(name = NULL, state.names = NULL, theta.names = NULL,
  simulate = NULL, genObsPoint = NULL, logPrior = NULL,
  pointLogLike = NULL)
}
\arguments{
\item{name}{character. Name of the model (required).}

\item{state.names}{character vector. Names of the state variables i.e. \code{c("S","I","R")} (required).}

\item{theta.names}{character vector. Names of the parameters i.e. \code{c("R0","infectious.period")} (required).}

\item{simulate}{\R-function to simulate forward the model (required). This function takes 3 arguments:
\itemize{
\item \code{theta} named numeric vector. Values of the parameters. Names should match \code{theta.names}.
\item \code{state.init} named numeric vector. Initial values of the state variables. Names should match \code{state.names}.
\item \code{times} numeric vector. Time sequence for which the state of the model is wanted; the first value of times must be the initial time, i.e. the time of \code{state.init}.
}
and returns a \code{data.fame} containing the simulated trajectories that is the values of the state variables (1 per column) at each observation time (1 per row). The first column is \code{time}.}

\item{genObsPoint}{\R-function that generates a (randomly sampled) observation point from a model point, using an observation model (optional). It thus acts as an inverse of \code{pointLogLike} (see below). This function takes 2 arguments
\itemize{
\item \code{model.point} named numeric vector. State of the model at a given point in time.
\item \code{theta} named numeric vector. Values of the parameters. Names should match \code{theta.names}.
}
and returns an observation point}

\item{logPrior}{\R-function that evaluates the log-prior density of the parameters at a given \code{theta} (optional). The function should take 1 argument:
\itemize{
    \item \code{theta} named numeric vector. Values of the parameters. Names should match \code{theta.names}.
}
and returns the logged value of the prior density distribution.}

\item{pointLogLike}{\R-function that evaluates the log-likelihood of one data point given the state of the model at the same time point. This function takes 3 arguments:
\itemize{
\item \code{data.point} named numeric vector. Observation time and observed data point.
\item \code{model.point} named numeric vector containing the state of the model at the observation time point.
\item \code{theta} named numeric vector. Parameter values. Useful since parameters are usually needed to compute the likelihood (i.e. reporting rate).
}
and returns the log-likelihood. (optional)}
}
\value{
a \code{fitmodel} object that is a \code{list} of 7 elements:
\itemize{
	\item \code{name} character, name of the model
	\item \code{state.names} vector, names of the state variables.
	\item \code{theta.names} vector, names of the parameters.
	\item \code{simulate} \R-function to simulate forward the model; usage: \code{simulate(theta,state.init,times)}.
	\item \code{genObsPoint} \R-function to generate simulated observations; usage: \code{genObsPoint(model.point, theta)}.
	\item \code{logPrior} \R-function to evaluate the log-prior of the parameter values; usage: \code{logPrior(theta)}.
	\item \code{pointLogLike} \R-function to evaluate the log-likelihood of one data point; usage: \code{pointLogLike(data.point, model.point, theta)}.
}
}
\description{
A \code{fitmodel} object is a \code{list} that stores some variables and functions that will be useful to simulate and fit your model during the course.
}
\examples{
# create a simple deterministic SIR model with constant population size

SIR_name <- "SIR with constant population size"
SIR_state.names <- c("S","I","R")
SIR_theta.names <- c("R0","D.inf")

SIR_simulateDeterministic <- function(theta,state.init,times) {

        SIR_ode <- function(time, state, parameters) {

                ## parameters
                beta <- parameters[["R0"]] / parameters[["D.inf"]]
                nu <- 1 / parameters[["D.inf"]]

                ## states
                S <- state[["S"]]
                I <- state[["I"]]
                R <- state[["R"]]

                N <- S + I + R

                dS <- -beta * S * I/N
                dI <- beta * S * I/N - nu * I
                dR <- nu * I

                return(list(c(dS, dI, dR)))
        }

	trajectory <- data.frame(ode(y=state.init,times=times,func=SIR_ode,parms=theta, method = "ode45"))

	return(trajectory)
}

## function to compute log-prior
SIR_logPrior <- function(theta) {

        ## uniform prior on R0: U[1,100]
        log.prior.R0 <- dunif(theta[["R0"]], min = 1, max = 100, log = TRUE)
        ## uniform prior on infectious period: U[0,30]
        log.prior.D <- dunif(theta[["D.inf"]], min = 0, max = 30, log = TRUE)

	return(log.prior.R0 + log.prior.D)
}

## function to compute the log-likelihood of one data point
SIR_pointLogLike <- function(data.point, model.point, theta){

        ## the prevalence is observed through a Poisson process
	return(dpois(x=data.point[["obs"]], lambda=model.point[["I"]], log=TRUE))
}

## function to generate observation from a model simulation
SIR_genObsPoint <- function(model.point, theta){

        ## the prevalence is observed through a Poisson process
        obs.point <- rpois(n=1, lambda=model.point[["I"]])

        return(obs.point)
}

## create deterministic SIR fitmodel
SIR <- fitmodel(
	name=SIR_name,
        state.names=SIR_state.names,
	theta.names=SIR_theta.names,
        simulate=SIR_simulateDeterministic,
	genObsPoint=SIR_genObsPoint,
	logPrior=SIR_logPrior,
	pointLogLike=SIR_pointLogLike)

## test them
theta <- c(R0 = 3, D.inf = 2)
state.init <- c(S = 999, I = 1, R = 0)
data(epi)

## SIR
## testFitmodel(fitmodel=SIR, theta=theta, state.init=state.init, data= epi1, verbose=TRUE)

}
\seealso{
\code{\link{testFitmodel}}
}

